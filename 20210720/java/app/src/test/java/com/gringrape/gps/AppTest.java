/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.gringrape.gps;

import org.junit.jupiter.api.Test;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import static org.junit.jupiter.api.Assertions.*;

class AppTest {
    Map<Integer, List<Integer>> connect(int n, int[][] edges) {
        Map<Integer, List<Integer>> network = new HashMap<>();

        IntStream.range(1, n + 1).forEach(i -> {
           network.put(i, new ArrayList<>());
        });

        Arrays.stream(edges).forEach(edge -> {
            int vertex1 = edge[0];
            int vertex2 = edge[1];

            network.get(vertex1).add(vertex2);
            network.get(vertex2).add(vertex1);
        });

        network.forEach((k, v)-> v.add(k));

        return network;
    }

    @Test void testNetwork() {
        Map<Integer, List<Integer>> network = connect(7, sampleEdges);

        assertTrue(network.get(1).contains(2));
    }

    void printArray(int[][] array) {
        IntStream.range(0, array.length).forEach(i -> {
            System.out.println(Arrays.toString(array[i]));
        });
    }

    int solution(int n, int m, int[][] edge_list, int k, int[] gps_log) {
        // 1. dp 테이블 그리기
        // - 행의 길이는 주어진 경로(gps_log)의 노드 개수
        // - 열의 길이는 노드 개수
        int pathLength = gps_log.length;

        int[][] mismatches = new int[pathLength][n];

        IntStream.range(0, pathLength).forEach(i -> {
            IntStream.range(0, n).forEach(j -> {
                mismatches[i][j] = 987654321;
            });
        });

        int last = gps_log[pathLength - 1];
        mismatches[0][last - 1] = 0;

        // 2. 테이블 순회 점화식 세우기
        Map<Integer, List<Integer>> network = connect(n, edge_list);
        IntStream.range(1, pathLength).forEach(i -> {
            IntStream.range(0, n).forEach(j -> {
                int node = j + 1;
                int pathNode = gps_log[pathLength - i - 1];
                // 현재 mismatch 값
                int currentMismatch = node == pathNode ? 0 : 1;
                // 이전 mismatch 의 최소값
                List<Integer> neighbors = network.get(node);
                Optional<Integer> min = neighbors.stream()
                        .map(neighbor -> mismatches[i - 1][neighbor - 1])
                        .min(Comparator.comparingInt(a -> a));

                min.ifPresent(integer -> mismatches[i][j] = integer + currentMismatch);
            });
        });

        printArray(mismatches);

        // 3. 테이블을 모두 순회해서 정답 반환하기

        int start = gps_log[0];
        int result = mismatches[pathLength - 1][start - 1];

        if (result > pathLength - 2) {
            return -1;
        }

        return result;
    }

    @Test void testSample() {
        assertEquals(
                solution(7, 10, sampleEdges, 6, sampleLogs),
                1
        );

        assertEquals(
                solution(7, 10, sampleEdges, 6, sampleLogs2),
                0
        );

        assertEquals(
                solution(7, 10, sampleEdges, 6, sampleLogs3),
                0
        );
    }

    final int[] sampleLogs = new int[]{1, 2, 3, 3, 6, 7};
    final int[] sampleLogs2 = new int[]{1, 2, 4, 6, 5, 7};
    final int[] sampleLogs3 = new int[]{1, 1, 1, 1, 1, 7};

    final int[][] sampleEdges = new int[][]{
            new int[]{1, 2},
            new int[]{1, 3},
            new int[]{2, 3},
            new int[]{2, 4},
            new int[]{3, 4},
            new int[]{3, 5},
            new int[]{4, 6},
            new int[]{5, 6},
            new int[]{5, 7},
            new int[]{6, 7},
    };
}
