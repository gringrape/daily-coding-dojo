# 같은 숫자는 싫어

## 구하는 것
- 연속적으로 나타나는 숫자를 하나만 남기고 제거(된 배열)

## 주어진 것
- 배열

## 알고 있는 것
- 중복 제거, Set 이용 가능
-> 틀렸음. 연속적으로 나타나는 숫자만 제거
- 서로 같은 군집을 다루는 것은 잘모름.

## 계획
- 작은 문제 부터 해결 [1, 1, 1] => 1

## 반성
### 틀린풀이
```javascript
const getLast = (arr) => arr.slice(-1)[0];

function solution(arr) {
  const reducer = (acc, num) => getLast(acc) === num ? acc : [...acc, num]; // n ** 2

  return arr.reduce(reducer, []);
}

test('solution', () => {
  expect(solution([1,1])).toEqual([1]);

  expect(solution([1, 1, 3, 3, 0, 1, 1])).toEqual([1, 3, 0, 1]);

  expect(solution([4, 4, 4, 3, 3])).toEqual([4, 3]);
});
```
최악의 경우 각각의 원소마다 배열을 새로 만들게 되므로, n ** 2 이 되어서 느리다.
효율성 테스트에 실패했다.
불변성을 어기고 push 로 처리해서 새로운 배열을 생성하지 않으면 일단 해결된다. 
다른 사람은 filter 를 써서 처리해주었다.

(1, 1, 1, 2, 2, 3, 3, 3, 0)

과 같이 있을때, 중복되는 군집중에서 마지막것만을 고르자는 전략이었다.
마지막것의 특징은 다음 것과 다르다는 것을 이용.

얻은것은 filter 라는 아이디어를 시각화해서 바라볼 수 있게 되었다는 것.
배열이나 스트림이 나열되어있을때, 어떤것들을 골라내야 한다. 
공통되는 규칙은 무엇이 있을까? 