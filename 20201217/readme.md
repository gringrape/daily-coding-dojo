# 같은 숫자는 싫어

## 구하는 것
- 연속적으로 나타나는 숫자를 하나만 남기고 제거(된 배열)

## 주어진 것
- 배열

## 알고 있는 것
- 중복 제거, Set 이용 가능
-> 틀렸음. 연속적으로 나타나는 숫자만 제거
- 서로 같은 군집을 다루는 것은 잘모름.

## 계획
- 작은 문제 부터 해결 [1, 1, 1] => 1

## 반성
### 틀린풀이
```javascript
const getLast = (arr) => arr.slice(-1)[0];

function solution(arr) {
  const reducer = (acc, num) => getLast(acc) === num ? acc : [...acc, num]; // n ** 2

  return arr.reduce(reducer, []);
}

test('solution', () => {
  expect(solution([1,1])).toEqual([1]);

  expect(solution([1, 1, 3, 3, 0, 1, 1])).toEqual([1, 3, 0, 1]);

  expect(solution([4, 4, 4, 3, 3])).toEqual([4, 3]);
});
```
최악의 경우 각각의 원소마다 배열을 새로 만들게 되므로, n ** 2 이 되어서 느리다.
효율성 테스트에 실패했다.
불변성을 어기고 push 로 처리해서 새로운 배열을 생성하지 않으면 일단 해결된다. 
다른 사람은 filter 를 써서 처리해주었다.

(1, 1, 1, 2, 2, 3, 3, 3, 0)

과 같이 있을때, 중복되는 군집중에서 마지막것만을 고르자는 전략이었다.
마지막것의 특징은 다음 것과 다르다는 것을 이용.

얻은것은 filter 라는 아이디어를 시각화해서 바라볼 수 있게 되었다는 것.
배열이나 스트림이 나열되어있을때, 어떤것들을 골라내야 한다. 
공통되는 규칙은 무엇이 있을까? 

# 3 진법 뒤집기
## 아는 것
손으로 진법 변환하기
계속해서 나눠서 나머지를 나열한다. 
언제까지 나누지? 몫이 0 일때까지,
## 계획
재귀로 풀어보자.
TDD 를 적극활용해서 가장 쉬운 진법 변환(작은 숫자) 부터 큰 숫자까지 난이도를 
점진적으로 올리자. 
## 반성
- 재귀 - 제너레이터 패턴을 활용했다. return 이 값을 돌려주지 않고 그냥 종료시키는것이 좀 이상하다
- 계획에서 문제를 쪼개고, 쪼개진 문제안에서도 난이도가 점진적으로 증가하도록 문제를 더 쪼갰다.
- 사실 진법 변환은 내장 함수가 있기 때문에 직접 할 필요가 없다.

## 반성 -> 개선
### 문제를 쪼개자 - 가로로, 또 세로로
문제를 가로로 쪼개자. 할일을 생각해보고 함수로 만들자.
이때, 함수를 연결하는 방식을 잘 설계하자. 체이닝, 파이프라이닝 등등
함수를 인자로 주고 받는 패턴도 잘 익히자 -> (함수형 프로그래밍 언어를 더 연습하자)

문제를 세로로 쪼개자. 횡적으로 쪼갠 문제를 난이도별로 쪼개자.
가장 쉬운 것 부터 점진적으로 해결하면서 과제를 지배한다는 느낌을 갖자. 

# 문자열 내 p 와 y 의 개수
## 구하는 것
문자열에 p 와 y 의 개수가 같은지 여부
## 주어진 것
50 이하의 자연수 길이를 가진 문자열.
문자열은 알파벳으로 이루어져 있음.
## 조건
대소문자 구별 X

## 계획
### 계획 1 - 각각을 세서 비교하자
- 문자열 내에서 특정 문자의 갯수를 세자
- p 와 y 의 갯수를 비교하자
### 계획 2
- 계획 1은 이 문제에서 overkill 인 것 같다.
- 한번에 셀 수 있을까?

## 반성
### 정규표현식의 활용
플래그를 넣기 g, i

# 체육복
## 구하는 것
체육 수업을 들을 수 있는 학생의 최댓값
체육수업을 듣는다 = 체육복이 있다
## 주어진 것
전체학생수
체육복을 잃어버린 학생
여유분이 있는 학생
## 조건
체육복은 바로 앞의 학생이나 바로 뒤의 학생에게 빌릴 수 있다.
여유분이 있는 학생이 도난 당했을 수 있다.
## 잘 모르는 것
탐욕법 -> 학습 필요
## 계획
여유분이 있는 학생 중에서 도난 당한 학생을 골라낸다
도난당한 '한'명이 체육복을 빌린다 -> 앞에서 없으면 뒤에서 
여러명이 체육복을 빌린다

## 잘 안된다.
함수들끼리 주고 받는 형식이 좀 더 통일될 필요가 있다.
중간에 데이터를 정제할 필요없이 합성함수 처리를 할 수 있도록.

## 반성
함수의 의사소통을 잘 설계하자.
분기 처리가 잘 이루어지지 않았다. 아직 개선책은 잘모르겠다. 
->
### 개선책
- find 를 사용해서 early return 처럼 결과가 생기면 바로 반환되도록 처리했다.
- 불필요한 메세지를 없앴다

# 2016년
## 구하는 것
2016 년의 특정일이 무슨 요일인지 요일
## 주어진 것
2016년 1월 1일 금요일, 윤년
## 자료
월마다 일수
31, 29, 31, 30, 31, 30, 
31, 31, 30, 31, 30, 31
요일
MON, TUE, WED, THU, FRI, SAT, SUN
## 계획
특정 일에서 부터 1 월 1 일까지 몇일이 경과했는지 구하기.
경과한 일 수를 7 로 나누어 나머지를 요일에 더하기.
## 반성
디버깅에서 시간이 지체된다. 원하는 결과가 나오지 않았을때,
디버거를 붙여서 변수값들을 다 확인하자.
인수 자리가 잘못들어가서 확인하느라 시간이 소모되었다.
RORO 패턴을 항상 사용해서 인수 확인하느라 시간소모하는 것을 줄이자.